/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package proyectoanalisis2017.pkg1;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;

import java.util.LinkedList;
import javax.swing.ImageIcon;
import javax.swing.JOptionPane;

/**
 *
 * @author Gianka
 */
public class PanelVentana extends javax.swing.JPanel {

    private Ciudad ciudad;
    private Ciudad ciudadPersonas;
    private AreaItems areaItems;
    private Boolean estaSelecionadoComponente;
    private Item itemSeleccionado;
    private int xImgSelecionada;
    private int yImgSelecionada;
    private final LinkedList<CarroMovimiento> carrosMovimiento;
    private LinkedList<PersonaMovimiento> personasMovimiento;
    private int opciones; //0: Para crear el mapa, 1: Para seleccionar el carro y nodo origen.
    private Ciudad auxCiudad;
    private int tipoCamino;
    private CarroMovimiento auxCarro;

    public PanelVentana() {
        initComponents();
        carrosMovimiento = new LinkedList<>();
        this.personasMovimiento = new LinkedList<>();
        xImgSelecionada = 0;
        yImgSelecionada = 0;
        itemSeleccionado = new Item();
        estaSelecionadoComponente = false;
        opciones = 0;
        tipoCamino = 0;
        auxCarro = null;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(255, 255, 255));
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                formMouseEntered(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        //Si opciones es igual a 2 es porque el usuario va a realizar un camino.
        if (opciones == 2) {
            auxCiudad = copiarCiudad(ciudad);
            Componente auxUbicacion;
            auxCarro = null;
//            destinos = new LinkedList<>();
            //Verificamos que el evento se de dentro del ancho y alto de la ciudad.
            if (evt.getX() < auxCiudad.getAnchoCiudad() && evt.getY() < auxCiudad.getAltoCiudad()) {
                //Recorro la lista de carros en movimiento para obtener el carro al cual se le dio click
                int auxNSeleccion = (int) evt.getY() / ciudad.getAltoCampo();
                int auxMSeleccion = (int) evt.getX() / ciudad.getAnchoCampo();
                //Y tambien obtenemos la ubicacion del carro que se toma como un nodo
                auxUbicacion = auxCiudad.getMatrizCiudad()[auxNSeleccion][auxMSeleccion];
                // Si la ubicaci칩n no es un nodo se debe marcar como nodo
                if (auxUbicacion != null) {
                    auxCiudad.marcarNodo(auxUbicacion);
                    for (int i = 0; i < carrosMovimiento.size(); i++) {
                        if (carrosMovimiento.get(i).getArea().contains(new Point(evt.getX(), evt.getY()))) {
                            auxCarro = carrosMovimiento.get(i);
                            auxCarro.setUbicacion(auxUbicacion);
                            auxCarro.parar();
                            auxCarro.getArea().setLocation((int) auxCarro.getUbicacion().getArea().getX(), (int) auxCarro.getUbicacion().getArea().getY());
                        }
                    }
                    //Pasamos a opciones 3
                    opciones = 3;
                }
            }
            //Si opciones es igual a 3 es porque ya esta seleccionado el carro y el nodo origen
        } else if (opciones == 3) {
            //Verificamos que el evento esta dentro del ancho y alto de ciudad.
            if (evt.getX() < auxCiudad.getAnchoCiudad() && evt.getY() < auxCiudad.getAltoCiudad()) {
                int auxi = (int) evt.getY() / auxCiudad.getAltoCampo();
                int auxj = (int) evt.getX() / auxCiudad.getAnchoCampo();
                //Obtenemos la ubicacion
                Componente destino = auxCiudad.getMatrizCiudad()[auxi][auxj];
                if (destino != null) {
                    if (!destino.getTipoVia().equals("")) {
                        //La marcamos si es nodo.
                        auxCiudad.marcarNodo(destino);
                    } else {
                        destino = buscarCarreteraCercana(auxi, auxj);
                        auxCiudad.marcarNodo(destino);

                    }
                    //A침ado a los destinos el nodo de destino
                    auxCarro.getDestinos().add(destino);
                }
            }
        }
    }//GEN-LAST:event_formMouseClicked
    /**
     * Evaluamos si el puntero del mouse esta en los limites del areaItem y si
     * presiona el click activamos la bandera estaSelecionadoComponente para
     * decir que ya estamos selecionado un item,seteamos el contador a cero para
     * que nos meustra la primera imagen de la lista de compoentes del item
     *
     * @param evt
     */
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed

        //Verifica si se presiono en alguno de los items del area de items
        if (evt.getX() > areaItems.getAnchoListaComponentesX1()) {
            for (int i = 0; i < areaItems.getListaItems().size(); i++) {
                if (areaItems.getListaItems().get(i).getArea().contains(new Point(evt.getX(), evt.getY()))) {
                    this.estaSelecionadoComponente = true;
                    areaItems.getListaItems().get(i).setContador(0);
                    this.itemSeleccionado = areaItems.getListaItems().get(i);
                }
            }
        }

    }//GEN-LAST:event_formMousePressed
    /**
     * Cuando se halla activado la bandera estaSelecionadoComponentes que es
     * cuando se preciona un item y ya cambiamos el X y Y de la imagen
     * selecionada para que la pinte de acuerdo donde va el puntero del mouse
     *
     * @param evt
     */
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        if (this.estaSelecionadoComponente) {
            this.xImgSelecionada = evt.getX();
            this.yImgSelecionada = evt.getY();
            repaint();
        }
    }//GEN-LAST:event_formMouseDragged
    /**
     * Cuando se suelta el click y adeas se tiene selecionado un item lo que
     * hace el release es que desactiva la bandera y posedemos a ubicar el
     * componente que se seleciono y ubicarlo en la matriz de la Ciudad
     *
     * @param evt
     */
    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        if (this.estaSelecionadoComponente) {
            try {
                this.estaSelecionadoComponente = false;
                this.xImgSelecionada = 0;
                this.yImgSelecionada = 0;
                int auxN = evt.getY() / ciudad.getAltoCampo();
                int auxM = evt.getX() / ciudad.getAnchoCampo();
                Componente auxComponente = new Componente(itemSeleccionado.getComponentes().get(itemSeleccionado.getContador()).getNombre());
                Rectangle area = new Rectangle(evt.getX(), evt.getY(), ciudad.getAnchoCampo(), ciudad.getAltoCampo());
                auxComponente.setArea(area);
                //Si ciudad en la posicion i, j del evento es diferente de null y si es una via y el componente tomado del area de items uno de las dos interrupciones
                if (ciudad.getMatrizCiudad()[auxN][auxM] != null && ciudad.esVia(ciudad.getMatrizCiudad()[auxN][auxM]) && (auxComponente.getNombre().equals("XX") || auxComponente.getNombre().equals("YY"))) {
                    //Se a침ade la interrupcion a la lista de interrupciones de la ciudad, con el componente anterior al de la interrupcion y la posicion en donde esta
                    ciudad.getInterrupciones().add(new Interrupcion((Componente) ciudad.getMatrizCiudad()[auxN][auxM].clone(), auxN, auxM));
                    //Se establece la interrupcion en la posicion i, j de la matriz de la ciudad
                    ciudad.getMatrizCiudad()[auxN][auxM] = auxComponente;
                    //Marca los nodos adyacentes a la interrupci칩n
                    ciudad.marcarNodosAdyacentes(auxN, auxM);
                    ciudad.modificarNodos();
                    //Se crea una ciudad local
                    for (int i = 0; i < carrosMovimiento.size(); i++) {
                        //Aqui si se mandara el grafo completo
                        if (carrosMovimiento.get(i).getTipo() != 0) {
                            Ciudad auxCiudad1 = copiarCiudad(carrosMovimiento.get(i).getCiudad());
                            auxCiudad1.getInterrupciones().add(new Interrupcion((Componente) auxCiudad1.getMatrizCiudad()[auxN][auxM].clone(), auxN, auxM));
                            //Se establece la interrupcion en la posicion i, j de la matriz de la ciudad
                            auxCiudad1.getMatrizCiudad()[auxN][auxM] = auxComponente;
                            //Marca los nodos adyacentes a la interrupci칩n
                            auxCiudad1.marcarNodosAdyacentes(auxN, auxM);
                            //HASTA AQUI COPIE LO DE ARRIBA
                            int auxNU = (int) (carrosMovimiento.get(i).getArea().getY() / ciudad.getAltoCampo());
                            int auxMU = (int) (carrosMovimiento.get(i).getArea().getX() / ciudad.getAnchoCampo());
                            auxCiudad1.marcarNodo(auxCiudad1.getMatrizCiudad()[auxNU][auxMU]);
                            auxCiudad1.modificarNodos();
                            GrafoDirigido auxGrafo1 = new GrafoDirigido(auxCiudad1.getCantidadNodos());
                            auxGrafo1.crearGrafo(copiarCiudad(auxCiudad1));
                            carrosMovimiento.get(i).parar();
                            carrosMovimiento.get(i).setGrafo(auxGrafo1);
//                            auxCiudad1.mostrarMatrizCiudad();
                            carrosMovimiento.get(i).setCiudad(auxCiudad1);
                            carrosMovimiento.get(i).reconstruirUbicacion();
                            carrosMovimiento.get(i).getArea().setLocation((int) carrosMovimiento.get(i).getUbicacion().getArea().getX(), (int) carrosMovimiento.get(i).getUbicacion().getArea().getY());
                            carrosMovimiento.get(i).reconstruirDestinos();
                            AlgoritmoRuta auxRuta;
                            if (carrosMovimiento.get(i).getTipo() == 1) {
                                auxRuta = new RutaCorta(carrosMovimiento.get(i).getCiudad().getCantidadNodos());
                            } else if (carrosMovimiento.get(i).getTipo() == 2) {
                                auxRuta = new RutaVeloz(carrosMovimiento.get(i).getCiudad().getCantidadNodos());
                            } else {
                                auxRuta = new RutaTrafico(carrosMovimiento.get(i).getCiudad().getCantidadNodos());
                                obtenerTrafico(carrosMovimiento.get(i));
                            }
                            //        System.out.println(auxRuta.getCantidadNodos());
                            auxRuta.llenarPesos(carrosMovimiento.get(i).getGrafo());
                            //auxRuta.mostrarPesos();
                            int matrizVertices[][] = auxRuta.floydWarshall();
                            int origen = carrosMovimiento.get(i).getUbicacion().getIdNodo();
                            LinkedList<Arista> auxCamino = new LinkedList<>();
                            for (int k = 0; k < carrosMovimiento.get(i).getDestinos().size(); k++) {
                                LinkedList<Arista> auxCamino1 = auxRuta.obtenerCamino(matrizVertices, origen, carrosMovimiento.get(i).getDestinos().get(k).getIdNodo(), carrosMovimiento.get(i).getGrafo());
                                for (int j = 0; j < auxCamino1.size(); j++) {
                                    System.out.println("camino: A" + auxCamino1.get(j).getX());
                                    System.out.println("camino: B" + auxCamino1.get(j).getY());
                                    auxCamino.add(auxCamino1.get(j));
                                }
                                origen = carrosMovimiento.get(i).getDestinos().get(k).getIdNodo();
                            }
                            carrosMovimiento.get(i).setCamino(auxCamino);
                            carrosMovimiento.get(i).iniciar();

                        } else {
                            Ciudad auxCiudad1 = copiarCiudad(ciudad);
                            GrafoDirigido auxGrafo1 = new GrafoDirigido(auxCiudad1.getCantidadNodos());
                            auxGrafo1.crearGrafo(copiarCiudad(ciudad));
                            carrosMovimiento.get(i).setGrafo(auxGrafo1);
                            carrosMovimiento.get(i).setCiudad(auxCiudad1);
                        }

                    }
                } //Si la ciudad en la posicion i,j es diferente de null y el componente tomado del area de items es el que remueve interrupciones y donde se tomo el evento en la posicion i, j es alguna de las interrupciones
                else if (ciudad.getMatrizCiudad()[auxN][auxM] != null && auxComponente.getNombre().equals("XXX") && (ciudad.getMatrizCiudad()[auxN][auxM].getNombre().equals("XX") || ciudad.getMatrizCiudad()[auxN][auxM].getNombre().equals("YY"))) {
                    //Recorro la lista de interrupciones para obtener la interrupciion
                    for (int i = 0; i < ciudad.getInterrupciones().size(); i++) {
                        //Si para cada interrupcion en i, j es igual a la posicion del evento
                        if (ciudad.getInterrupciones().get(i).getI() == auxN && ciudad.getInterrupciones().get(i).getJ() == auxM) {
                            //Le asigno el anterior componente a la posicion i, j de la matriz de la ciudad.
                            ciudad.getMatrizCiudad()[auxN][auxM] = ciudad.getInterrupciones().get(i).getComponenteAnterior();
                        }
                    }
                    //Procedo con la eliminacion de nodos adyacentes.
                    ciudad.eliminarNodosAdyacentes(auxN, auxM);
                    ciudad.modificarNodos();
                    for (int i = 0; i < carrosMovimiento.size(); i++) {
                        if (carrosMovimiento.get(i).getTipo() != 0) {

                            Ciudad auxCiudad1 = copiarCiudad(ciudad);
                            //HASTA AQUI COPIE LO DE ARRIBA
                            int auxNU = (int) (carrosMovimiento.get(i).getArea().getY() / ciudad.getAltoCampo());
                            int auxMU = (int) (carrosMovimiento.get(i).getArea().getX() / ciudad.getAnchoCampo());
                            auxCiudad1.marcarNodo(auxCiudad1.getMatrizCiudad()[auxNU][auxMU]);
                            carrosMovimiento.get(i).setCiudad(auxCiudad1);
                            carrosMovimiento.get(i).recuperarDestinos();
                            carrosMovimiento.get(i).getCiudad().modificarNodos();
                            GrafoDirigido auxGrafo1 = new GrafoDirigido(carrosMovimiento.get(i).getCiudad().getCantidadNodos());
                            auxGrafo1.crearGrafo(copiarCiudad(carrosMovimiento.get(i).getCiudad()));
                            carrosMovimiento.get(i).parar();
                            carrosMovimiento.get(i).setGrafo(auxGrafo1);

                            carrosMovimiento.get(i).reconstruirUbicacion();
                            carrosMovimiento.get(i).getArea().setLocation((int) carrosMovimiento.get(i).getUbicacion().getArea().getX(), (int) carrosMovimiento.get(i).getUbicacion().getArea().getY());
                            carrosMovimiento.get(i).reconstruirDestinos();
                            System.out.println("Muestro ciudad que queda");
                            carrosMovimiento.get(i).getCiudad().mostrarMatrizCiudad();
                            AlgoritmoRuta auxRuta;
                            if (carrosMovimiento.get(i).getTipo() == 1) {
                                auxRuta = new RutaCorta(carrosMovimiento.get(i).getCiudad().getCantidadNodos());
                            } else if (carrosMovimiento.get(i).getTipo() == 2) {
                                auxRuta = new RutaVeloz(carrosMovimiento.get(i).getCiudad().getCantidadNodos());
                            } else {
                                auxRuta = new RutaTrafico(carrosMovimiento.get(i).getCiudad().getCantidadNodos());
                                obtenerTrafico(carrosMovimiento.get(i));
                            }
                            //        System.out.println(auxRuta.getCantidadNodos());
                            auxRuta.llenarPesos(carrosMovimiento.get(i).getGrafo());
                            //auxRuta.mostrarPesos();
                            int matrizVertices[][] = auxRuta.floydWarshall();
                            int origen = carrosMovimiento.get(i).getUbicacion().getIdNodo();
                            LinkedList<Arista> auxCamino = new LinkedList<>();
                            for (int k = 0; k < carrosMovimiento.get(i).getDestinos().size(); k++) {
                                LinkedList<Arista> auxCamino1 = auxRuta.obtenerCamino(matrizVertices, origen, carrosMovimiento.get(i).getDestinos().get(k).getIdNodo(), carrosMovimiento.get(i).getGrafo());
                                for (int j = 0; j < auxCamino1.size(); j++) {
                                    System.out.println("camino: A" + auxCamino1.get(j).getX());
                                    System.out.println("camino: B" + auxCamino1.get(j).getY());
                                    auxCamino.add(auxCamino1.get(j));
                                }
                                origen = carrosMovimiento.get(i).getDestinos().get(k).getIdNodo();
                            }
                            carrosMovimiento.get(i).setCamino(auxCamino);
                            carrosMovimiento.get(i).iniciar();
                        } else if (carrosMovimiento.get(i).getCamino().isEmpty()) { //Si el carro esta sin camino es porque esta parado
                            Ciudad auxCiudad1 = copiarCiudad(ciudad); //Copio la ciudad para el caso especifico del carro
                            int auxN2 = (int) (carrosMovimiento.get(i).getArea().getY() / ciudad.getAltoCampo());
                            int auxM2 = (int) (carrosMovimiento.get(i).getArea().getX() / ciudad.getAnchoCampo());
                            auxCiudad1.marcarNodo(auxCiudad1.getMatrizCiudad()[auxN2][auxM2]); //Tengo que marcar como nodo la posicion en donde se encuentra el carro, pero es al auxiliar de la ciudad.
                            auxCiudad1.modificarNodos();
                            GrafoDirigido auxGrafo1 = new GrafoDirigido(auxCiudad1.getCantidadNodos());
                            auxGrafo1.crearGrafo(auxCiudad1);
                            carrosMovimiento.get(i).setGrafo(auxGrafo1);
                            carrosMovimiento.get(i).setCiudad(auxCiudad1);
                            carrosMovimiento.get(i).setTipo(0);

                            int m = auxCiudad1.getMatrizCiudad()[auxN2][auxM2].getIdNodo();
                            carrosMovimiento.get(i).buscarCamino(m);
                            carrosMovimiento.get(i).iniciar();
                        } else {
                            Ciudad auxCiudad1 = copiarCiudad(ciudad); //Copio la ciudad para el caso especifico del carro
                            GrafoDirigido auxGrafo1 = new GrafoDirigido(auxCiudad1.getCantidadNodos());
                            auxGrafo1.crearGrafo(auxCiudad1);
                            carrosMovimiento.get(i).setGrafo(auxGrafo1);
                            carrosMovimiento.get(i).setCiudad(auxCiudad1);
                        }
                    }
                } //Si el componente no es una de las interrupciones ni el que borra las interrupciones es un componente para pintar en el mapa.
                else if (!auxComponente.getNombre().equals("XX") && !auxComponente.getNombre().equals("YY") && !auxComponente.getNombre().equals("XXX")) {
                    ciudad.getMatrizCiudad()[auxN][auxM] = auxComponente;
                }

            } catch (Exception e) {
                System.out.println("Error en el panel: " + e.toString());
            }
            repaint();
        }
    }//GEN-LAST:event_formMouseReleased

    private void formMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseEntered
        // TODO add your handling code here:
    }//GEN-LAST:event_formMouseEntered

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
        // TODO add your handling code here:

    }//GEN-LAST:event_formKeyPressed

    /**
     * Permite hacer una copia de la ciudad para cada vehiculo y la
     * reconstrucci칩n del grafo
     *
     * @param ciudad que se va a copiar
     * @return una ciudad copiada
     */
    public Ciudad copiarCiudad(Ciudad ciudad) {
        Ciudad copiaCiudad = (Ciudad) ciudad.clone();
        copiaCiudad.setMatrizCiudad(null);
        Componente[][] compiaComponentes = new Componente[copiaCiudad.getN()][copiaCiudad.getM()];
        copiaCiudad.setMatrizCiudad(compiaComponentes);
        for (int i = 0; i < ciudad.getN(); i++) {
            for (int j = 0; j < ciudad.getM(); j++) {
                if (ciudad.getMatrizCiudad()[i][j] != null) {
                    copiaCiudad.getMatrizCiudad()[i][j] = (Componente) ciudad.getMatrizCiudad()[i][j].clone();
                }
            }
        }
        return copiaCiudad;
    }

    /**
     * Permite la modificaci칩n de la ciudad y el grafo con el nodo de ubicacion
     * del vehiculo y sus destinos ademas calcula el camino mino segun el tipo
     * de ruta selecionado
     */
    public void modificarGrafo() {
        auxCiudad.modificarNodos();
        Ciudad auxCiudad1 = copiarCiudad(auxCiudad);
        GrafoDirigido auxGrafo1 = new GrafoDirigido(auxCiudad1.getCantidadNodos());  // Creo un grafo que se le asignara al carro
        auxGrafo1.crearGrafo(copiarCiudad(auxCiudad));    //Creo el grafo con la ciudad.
        auxCarro.setGrafo(auxGrafo1);   //Seteo el grafo al carro.
        auxCarro.setCiudad(auxCiudad1);
        auxCarro.setTipo(tipoCamino); //Seteo el tipo de carro.
        auxCarro.reconstruirDestinos();
        auxCarro.reconstruirUbicacion();
        //auxCarro.getArea().setLocation((int) auxCarro.getUbicacion().getArea().getX(), (int) auxCarro.getUbicacion().getArea().getY());
        auxCarro.getCiudad().mostrarMatrizCiudad();
//        mostrarGrafo(auxGrafo1);
        AlgoritmoRuta auxRuta;
        if (auxCarro.getTipo() == 1) {
            auxRuta = new RutaCorta(auxCarro.getCiudad().getCantidadNodos());
        } else if (auxCarro.getTipo() == 2) {
            auxRuta = new RutaVeloz(auxCarro.getCiudad().getCantidadNodos());
        } else {
            auxRuta = new RutaTrafico(auxCarro.getCiudad().getCantidadNodos());
            obtenerTrafico(auxCarro);
        }
//        System.out.println(auxRuta.getCantidadNodos());
        auxRuta.llenarPesos(auxCarro.getGrafo());
        //auxRuta.mostrarPesos();
        int matrizVertices[][] = auxRuta.floydWarshall();
        int origen = auxCarro.getUbicacion().getIdNodo();
        LinkedList<Arista> auxCamino = new LinkedList<>();
        for (int i = 0; i < auxCarro.getDestinos().size(); i++) {
            LinkedList<Arista> auxCamino1 = auxRuta.obtenerCamino(matrizVertices, origen, auxCarro.getDestinos().get(i).getIdNodo(), auxCarro.getGrafo());
            for (int j = 0; j < auxCamino1.size(); j++) {
                System.out.println("camino: A" + auxCamino1.get(j).getX());
                System.out.println("camino: B" + auxCamino1.get(j).getY());
                auxCamino.add(auxCamino1.get(j));
            }
            origen = auxCarro.getDestinos().get(i).getIdNodo();
        }
        auxCarro.setCamino(auxCamino);
        String color = JOptionPane.showInputDialog(this, "Ingese el color", "Color", JOptionPane.INFORMATION_MESSAGE);
        auxCarro.obtenerCaminoPintar(color);
        auxCarro.iniciar();
    }

    /**
     * Se obtiene el trafico de la ciudad para el grafo en un momento
     * determinado Se inicializa el trafico de las aristas con 0 y se procede a
     * realizar un recorrido del grafo obteniendo el numero de vehiculos en cada
     * arista
     *
     * @param carro
     */
    public void obtenerTrafico(CarroMovimiento carro) {
        for (int j = 0; j < carro.getGrafo().getGrafo().length; j++) {
            for (int k = 0; k < carro.getGrafo().getGrafo()[j].length; k++) {
                if (carro.getGrafo().getGrafo()[j][k] != null) {
                    carro.getGrafo().getGrafo()[j][k].setTrafico(0);
                }
            }
        }
        for (int i = 0; i < carrosMovimiento.size(); i++) {
            if (carrosMovimiento.get(i).getId() != carro.getId() && carrosMovimiento.get(i).getCamino() != null) {
                Arista arista = carrosMovimiento.get(i).getCamino().getFirst();
                for (int j = 0; j < carro.getGrafo().getGrafo().length; j++) {
                    for (int k = 0; k < carro.getGrafo().getGrafo()[j].length; k++) {
                        if (carro.getGrafo().getGrafo()[j][k] != null && arista.getX() == carro.getGrafo().getGrafo()[j][k].getX()
                                && arista.getY() == carro.getGrafo().getGrafo()[j][k].getY()) {
                            carro.getGrafo().getGrafo()[j][k].setTrafico(carro.getGrafo().getGrafo()[j][k].getTrafico() + 1);
                        }
                    }
                }
            }
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g); //To change body of generated methods, choose Tools | Templates.
        if (ciudad != null && areaItems != null) {
            //Se pinta el fondo
            g.drawImage(new ImageIcon(getClass().getResource("../ImgComponentes/Fondo.jpg")).getImage(), 0, 0, ciudad.getAnchoCiudad(), ciudad.getAltoCiudad(), this);
            g.setColor(Color.decode("#FC4600"));
            g.fillRect(areaItems.getAnchoListaComponentesX1(), 0, (areaItems.getAnchoListaComponentesX2() - ciudad.getAnchoCiudad()) * 2, ciudad.getAltoCiudad());
            g.setColor(Color.BLACK);
            //Se pinta el area de items
            pintarComponentes(g);
            // lineas de referencia de las areas de la aplicacion
            g.drawRect(0, 0, ciudad.getAnchoCiudad(), ciudad.getAltoCiudad());
            //Se pinta la ciudad
            pintarCiudad(g);
            //pinta los carros automaticos
            for (int i = 0; i < this.carrosMovimiento.size(); i++) {
                g.drawImage(new ImageIcon(getClass().getResource(this.carrosMovimiento.get(i).getRuta())).getImage(), (int) this.carrosMovimiento.get(i).getArea().getX(), (int) this.carrosMovimiento.get(i).getArea().getY(), ciudad.getAnchoCampo(), ciudad.getAltoCampo(), this);

            }
            //pinta las personas en movimiento
            for (int i = 0; i < this.personasMovimiento.size(); i++) {
                g.drawImage(new ImageIcon(getClass().getResource(this.personasMovimiento.get(i).getRuta())).getImage(), (int) this.personasMovimiento.get(i).getArea().getX(), (int) this.personasMovimiento.get(i).getArea().getY(), (int) ((int)ciudad.getAnchoCampo()*0.50), (int) ( ciudad.getAltoCampo()*(0.50)), this);

            }
            //pinta la anamiacion de colocar imagen en el tablero
            //El 0 es el X1 de la ciudad.
            if (this.estaSelecionadoComponente && this.xImgSelecionada > 0 && this.xImgSelecionada < ciudad.getAnchoCiudad() && this.yImgSelecionada > 0 && this.yImgSelecionada < ciudad.getAltoCiudad()) {
                g.drawImage(new ImageIcon(getClass().getResource(itemSeleccionado.getComponentes().get(itemSeleccionado.getContador()).getRuta())).getImage(), this.xImgSelecionada, this.yImgSelecionada, 100, 100, this);
                int auxN = yImgSelecionada / ciudad.getAltoCampo();
                int auxM = xImgSelecionada / ciudad.getAnchoCampo();
                g.drawRect(auxM * ciudad.getAnchoCampo(), auxN * ciudad.getAltoCampo(), ciudad.getAnchoCampo(), ciudad.getAltoCampo());
            }
            pintarCamino(g);
        }

    }

    /**
     * pintamos la lista de los item que podemos selecionar y poner en la ciudad
     *
     * @param g grafico del panel que sirve como lienzo
     */
    private void pintarComponentes(Graphics g) {
        for (int i = 0; i < areaItems.getListaItems().size(); i++) {
            Item auxItem;
            auxItem = areaItems.getListaItems().get(i);
            g.drawImage(new ImageIcon(getClass().getResource(auxItem.getComponentes().getFirst().getRuta())).getImage(), auxItem.getArea().x, auxItem.getArea().y, auxItem.getArea().width, auxItem.getArea().height, this);
        }
    }

    /**
     * Permite trazar el camino de un vehiculo segun las aristas que recorrera
     *
     * @param g
     */
    private void pintarCamino(Graphics g) {
        for (int i = 0; i < carrosMovimiento.size(); i++) {
            if (!carrosMovimiento.get(i).getCaminoPintar().isEmpty()) {
                g.setColor(carrosMovimiento.get(i).getColor());
                for (int j = 0; j < carrosMovimiento.get(i).getCaminoPintar().size(); j++) {
                    int x1 = carrosMovimiento.get(i).getCaminoPintar().get(j).getX1();
                    int y1 = carrosMovimiento.get(i).getCaminoPintar().get(j).getY1();
                    int x2 = carrosMovimiento.get(i).getCaminoPintar().get(j).getX2();
                    int y2 = carrosMovimiento.get(i).getCaminoPintar().get(j).getY2();
                    g.drawLine(x1, y1, x2, y2);
                }
            }
        }
    }

    public void setCiudad(Ciudad ciudad) {
        this.ciudad = ciudad;
    }

    public void setAreaItems(AreaItems areaItems) {
        this.areaItems = areaItems;
    }

    public void setTipoCamino(int tipoCamino) {
        this.tipoCamino = tipoCamino;
    }

    /**
     * Permite en recorrer la matriz de componentes y pintar las difrentes
     * imagenes asociadas ala posicion de la matriz en caso de que sea null es
     * que no hay ningun componente entonces no se pinta nada
     *
     * @param g grafico del panel que sirve como lienzo
     */
    private void pintarCiudad(Graphics g) {
        for (int i = 0; i < this.ciudad.getN(); i++) {
            for (int j = 0; j < this.ciudad.getM(); j++) {
                if (ciudad.getMatrizCiudad()[i][j] != null && !ciudad.getMatrizCiudad()[i][j].getNombre().equals("0")) {
                    g.drawImage(new ImageIcon(getClass().getResource(ciudad.getMatrizCiudad()[i][j].getRuta())).getImage(), ciudad.getAnchoCampo() * j, ciudad.getAltoCampo() * i, ciudad.getAnchoCampo(), this.ciudad.getAltoCampo(), this);
                }
            }
        }
    }

    /**
     * Permite rotar un componente
     */
    public void girarItem() {
        if (itemSeleccionado.getContador() == itemSeleccionado.getComponentes().size() - 1) {
            this.itemSeleccionado.setContador(0);
        } else {
            itemSeleccionado.setContador(itemSeleccionado.getContador() + 1);
        }
        repaint();
    }

    public LinkedList<CarroMovimiento> getCarrosMovimiento() {
        return carrosMovimiento;
    }

    public int getOpciones() {
        return opciones;
    }

    public void setOpciones(int opciones) {
        this.opciones = opciones;
    }

    public void setAuxCiudad(Ciudad auxCiudad) {
        this.auxCiudad = auxCiudad;
    }

    public Ciudad getCiudad() {
        return ciudad;
    }

    /**
     * Permite buscar la carretera mas cerca al destino seleccionado
     *
     * @param x
     * @param y Posiciones del destino
     * @return el componente carretera mas cercano al destino seleccionado
     */
    private Componente buscarCarreteraCercana(int x, int y) {
        Componente respuesta = null;
        int comIzq = valorCarreteraIzq(x, y - 1);
        int comDer = valorCarreteraDer(x, y + 1);
        int comArriba = valorCarreteraArriba(x - 1, y);
        int comAbajo = valorCarreteraAbajo(x + 1, y);
        if (comIzq < comDer) {
            respuesta = mirarCarreteraIzq(x, y - 1);
        } else {
            if (comDer < comArriba) {
                respuesta = mirarCarreteraDer(x, y + 1);
            } else {
                if (comArriba < comAbajo) {
                    respuesta = mirarCarreteraArriba(x - 1, y);
                } else {
                    respuesta = mirarCarreteraAbajo(x + 1, y);
                }
            }
        }
        return respuesta;
    }

    /**
     * Verifica si es posible obtener una carretera a la izquierda
     *
     * @param x
     * @param y Posiciones del destino
     * @return un componente carretera a la izquierda si existe
     */
    public Componente mirarCarreteraIzq(int x, int y) {
        Componente respuesta = null;
        Boolean bandera = true;
        while (y >= 0 && bandera) {
            if (auxCiudad.getMatrizCiudad()[x][y] != null && !auxCiudad.getMatrizCiudad()[x][y].getTipoVia().equals("")) {
                respuesta = auxCiudad.getMatrizCiudad()[x][y];
                bandera = false;
            }
            y--;
        }
        return respuesta;
    }

    /**
     * Verifica si es posible obtener una carretera a la derecha
     *
     * @param x
     * @param y Posiciones del destino
     * @return un componente carretera a la derecha si existe
     */
    public Componente mirarCarreteraDer(int x, int y) {
        Componente respuesta = null;
        Boolean bandera = true;
        while (y < auxCiudad.getMatrizCiudad().length && bandera) {
            if (auxCiudad.getMatrizCiudad()[x][y] != null && !auxCiudad.getMatrizCiudad()[x][y].getTipoVia().equals("")) {
                respuesta = auxCiudad.getMatrizCiudad()[x][y];
                bandera = false;
            }
            y++;
        }
        return respuesta;

    }

    /**
     * Verifica si es posible obtener una carretera hacia arriba del destino
     *
     * @param x
     * @param y Posiciones del destino
     * @return un componente carretera arriba del destino si existe
     */
    public Componente mirarCarreteraArriba(int x, int y) {
        Componente respuesta = null;
        Boolean bandera = true;
        while (x >= 0 && bandera) {
            if (auxCiudad.getMatrizCiudad()[x][y] != null && !auxCiudad.getMatrizCiudad()[x][y].getTipoVia().equals("")) {
                respuesta = auxCiudad.getMatrizCiudad()[x][y];
                bandera = false;
            }
            x--;
        }
        return respuesta;

    }

    /**
     * Verifica si es posible obtener una carretera hacia abajo del destino
     *
     * @param x
     * @param y Posiciones del destino
     * @return un componente carretera abajo del destino si existe
     */
    public Componente mirarCarreteraAbajo(int x, int y) {
        Componente respuesta = null;
        Boolean bandera = true;
        while (x < auxCiudad.getMatrizCiudad().length && bandera) {
            if (auxCiudad.getMatrizCiudad()[x][y] != null && !auxCiudad.getMatrizCiudad()[x][y].getTipoVia().equals("")) {
                respuesta = auxCiudad.getMatrizCiudad()[x][y];
                bandera = false;
            }
            x++;
        }
        return respuesta;
    }

    public int valorCarreteraIzq(int x, int y) {
        int respuesta = 0;
        Boolean bandera = true;
        while (y >= 0 && bandera) {
            respuesta++;
            if (auxCiudad.getMatrizCiudad()[x][y] != null && !auxCiudad.getMatrizCiudad()[x][y].getTipoVia().equals("")) {
                bandera = false;
            }
            y--;
        }
        if (bandera) {
            respuesta = Integer.MAX_VALUE;
        }
        return respuesta;
    }

    public int valorCarreteraDer(int x, int y) {
        int respuesta = 0;
        Boolean bandera = true;
        while (y < auxCiudad.getMatrizCiudad().length && bandera) {
            respuesta++;
            if (auxCiudad.getMatrizCiudad()[x][y] != null && !auxCiudad.getMatrizCiudad()[x][y].getTipoVia().equals("")) {

                bandera = false;
            }
            y++;
        }
        if (bandera) {
            respuesta = Integer.MAX_VALUE;
        }
        return respuesta;

    }

    public int valorCarreteraArriba(int x, int y) {
        int respuesta = 0;
        Boolean bandera = true;
        while (x >= 0 && bandera) {
            respuesta++;
            if (auxCiudad.getMatrizCiudad()[x][y] != null && !auxCiudad.getMatrizCiudad()[x][y].getTipoVia().equals("")) {
                bandera = false;
            }
            x--;
        }
        if (bandera) {
            respuesta = Integer.MAX_VALUE;
        }
        return respuesta;

    }

    public int valorCarreteraAbajo(int x, int y) {
        int respuesta = 0;
        Boolean bandera = true;
        while (x < auxCiudad.getMatrizCiudad().length && bandera) {
            respuesta++;
            if (auxCiudad.getMatrizCiudad()[x][y] != null && !auxCiudad.getMatrizCiudad()[x][y].getTipoVia().equals("")) {
                bandera = false;
            }
            x++;
        }
        if (bandera) {
            respuesta = Integer.MAX_VALUE;
        }
        return respuesta;
    }

    public Ciudad getCiudadPersonas() {
        return ciudadPersonas;
    }

    public void setCiudadPersonas(Ciudad ciudadPersonas) {
        this.ciudadPersonas = ciudadPersonas;
    }

    public LinkedList<PersonaMovimiento> getPersonasMovimiento() {
        return personasMovimiento;
    }

    public void setPersonasMovimiento(LinkedList<PersonaMovimiento> personasMovimiento) {
        this.personasMovimiento = personasMovimiento;
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
